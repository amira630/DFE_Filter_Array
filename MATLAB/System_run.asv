clear
clc

% Read binary configuration from file
config = readBinaryConfig('cfg.txt');

% Extract values from binary configuration
% Signal configuration flags (bits 1-3)
f = config(1);
a = config(2);  
s = config(3);

% Bypass flags (bits 4-7)
bypass_frac_dec = config(4);
bypass_iir_24   = config(5);
bypass_iir_5    = config(6);
bypass_cic      = config(7);

% CIC Configuration (bits 8-12 as 5-bit value)
cic_decf_binary = config(8:12);
cic_decf = binaryVectorToDecimal(cic_decf_binary);

% Default parameters
default_freq = 1e5;      % 100 kHz
default_amp = 0.25;      % Default amplitude
default_shape = 'sine';  % Default shape

% Parameter ranges for randomization
freq_range = [50e3, 200e3];   % Frequency range: 50 kHz to 200 kHz
amp_range = [0.1, 0.5];       % Amplitude range: 0.1 to 0.5
shape_options = {'sine', 'square', 'triangular'};

% Determine final parameters based on flags
if f == 1
    f_sig = freq_range(1) + (freq_range(2) - freq_range(1)) * rand();
else
    f_sig = default_freq;
end

if a == 1
    amplitude = amp_range(1) + (amp_range(2) - amp_range(1)) * rand();
else
    amplitude = default_amp;
end

if s == 1
    shape_idx = randi([1, length(shape_options)]);
    signal_shape = shape_options{shape_idx};
else
    signal_shape = default_shape;
end

% Display selected parameters
fprintf('Generated signal parameters:\n');
fprintf('  Frequency: %.2f kHz\n', f_sig/1000);
fprintf('  Amplitude: %.3f\n', amplitude);
fprintf('  Shape: %s\n', signal_shape);
fprintf('Bypass settings:\n');
fprintf('  Fractional Decimator: %d\n', bypass_frac_dec);
fprintf('  IIR 2.4MHz: %d\n', bypass_iir_24);
fprintf('  IIR 5MHz: %d\n', bypass_iir_5);
fprintf('  CIC: %d\n', bypass_cic);

Fs = 9e6;        
N  = 48000;      

t = (0 : N - 1)' / Fs;                    

% Generate clean signal based on selected shape
switch signal_shape
    case 'sine'
        x_real_clean = amplitude * sin(2 * pi * f_sig * t);
    case 'square'
        x_real_clean = amplitude * square(2 * pi * f_sig * t);
    case 'triangular'
        x_real_clean = amplitude * sawtooth(2 * pi * f_sig * t, 0.5);
end

% Add interference
f_intf_2_4 = 2.4e6;    
f_intf_5 = 5e6;      
A_intf_2_4 = 0.2;
A_intf_5 = 0.2;

intf1 = (A_intf_2_4 * sin(2 * pi * f_intf_2_4 * t));
intf2 = (A_intf_5 * sin(2 * pi * f_intf_5 * t));
interference = intf1 + intf2;
x_real_noisy = x_real_clean + interference;

x_quantized_noisy = fi(x_real_noisy, 1, 16, 15);

% Processing chain with bypass options
current_signal = x_quantized_noisy;

% Stage 1: Fractional Decimator
if bypass_frac_dec == 0
    fprintf('Applying Fractional Decimator...\n');
    Hd_Fractional_Decimator = Fractional_Decimator();
    current_signal = step(Hd_Fractional_Decimator, current_signal);
else
    fprintf('Bypassing Fractional Decimator\n');
end

% Stage 2: IIR 2.4MHz Notch Filter
if bypass_iir_24 == 0
    fprintf('Applying IIR 2.4MHz Notch Filter...\n');
    Hd_IIR_2_4 = IIR_2_4();
    current_signal = filter(Hd_IIR_2_4, current_signal);
else
    fprintf('Bypassing IIR 2.4MHz Notch Filter\n');
end

% Stage 3: IIR 5MHz Notch Filter (both IIR_1 and IIR_2)
if bypass_iir_5 == 0
    fprintf('Applying IIR 5MHz Notch Filter...\n');
    Hd_IIR_1 = IIR_1(); 
    Hd_IIR_2 = IIR_2();
    y_filtered_1 = filter(Hd_IIR_1, current_signal);
    current_signal = filter(Hd_IIR_2, y_filtered_1);
else
    fprintf('Bypassing IIR 5MHz Notch Filter\n');
end

% Stage 4: CIC Filter
if bypass_cic == 0
    fprintf('Applying CIC Filter with decimation factor %d...\n', cic_decf);
    Hd_cic = CIC(cic_decf);
    current_signal = step(Hd_cic, current_signal);
else
    fprintf('Bypassing CIC Filter\n');
end

% Final output
y_final = current_signal;

fprintf('Processing complete!\n');