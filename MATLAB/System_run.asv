clear
clc

% Read binary configuration from file
config = readBinaryConfig('cfg.txt');

% Extract values from binary configuration
% Signal configuration flags (bits 2-4)
f = config(2);
a = config(3);  
s = config(4);

% CIC Configuration (bits 5-9 as 5-bit value)
cic_decf_binary = config(5:9);
cic_decf = binaryVectorToDecimal(cic_decf_binary);

% Floating vs Fixed Point
fi_vs_float_var = config(1);

% Default parameters
default_freq = 1e5;      % 100 kHz
default_amp = 0.25;      % Default amplitude
default_shape = 'sine';  % Default shape

% Parameter ranges for randomization
freq_range = [50e3, 200e3];   % Frequency range: 50 kHz to 200 kHz
amp_range = [0.1, 1];       % Amplitude range: 0.1 to 1
shape_options = {'square', 'triangular'};

% Determine final parameters based on flags
if f == 1
    f_sig = freq_range(1) + (freq_range(2) - freq_range(1)) * rand();
else
    f_sig = default_freq;
end

if a == 1
    amplitude = amp_range(1) + (amp_range(2) - amp_range(1)) * rand();
else
    amplitude = default_amp;
end

if s == 1
    shape_idx = randi([1, length(shape_options)]);
    signal_shape = shape_options{shape_idx};
else
    signal_shape = default_shape;
end

% Map signal shape to 2-bit binary code
switch signal_shape
    case 'sine'
        shape_code = '00';
    case 'square'
        shape_code = '01';
    case 'triangular'
        shape_code = '10';
    otherwise
        shape_code = '00';  % Default to sine
end

% Write shape code to text file
shape_filename = 'signal_shape_code.txt';
fid = fopen(shape_filename, 'w');
if fid == -1
    error('Cannot open file %s for writing.', shape_filename);
end
fprintf(fid, '%s', shape_code);
fclose(fid);

fprintf('Shape code written to: %s\n', shape_filename);
fprintf('Signal shape: %s -> 2-bit code: %s\n\n', signal_shape, shape_code);

% Display configuration
fprintf('Binary Configuration:\n');
fprintf('Raw bits: ');
fprintf('%d', config);
fprintf('\n\n');

fprintf('Parsed Configuration:\n');
fprintf('Signal flags - f:%d, a:%d, s:%d\n', f, a, s);
fprintf('CIC decf (binary %s) = %d\n\n', ...
        num2str(cic_decf_binary), cic_decf);
fprintf('Generated signal - Freq: %.2f kHz, Amp: %.3f, Shape: %s\n\n', ...
        f_sig/1000, amplitude, signal_shape);

Fs = 9e6;        
N  = 48000;      

t = (0 : N - 1)' / Fs;                    

% Generate clean signal based on selected shape
switch signal_shape
    case 'sine'
        x_real_clean = amplitude * sin(2 * pi * f_sig * t);
    case 'square'
        x_real_clean = amplitude * square(2 * pi * f_sig * t);
    case 'triangular'
        x_real_clean = amplitude * sawtooth(2 * pi * f_sig * t, 0.5);
end

% Add interference
f_intf_2_4 = 2.4e6;    
f_intf_5 = 5e6;      
A_intf_2_4 = 0.2;
A_intf_5 = 0.2;

intf1 = (A_intf_2_4 * sin(2 * pi * f_intf_2_4 * t));
intf2 = (A_intf_5 * sin(2 * pi * f_intf_5 * t));
interference = intf1 + intf2;
x_real_noisy = x_real_clean + interference;

x_quantized_noisy = fi(x_real_noisy, 1, 16, 15);

% Generate all bypass combinations
% Based on your description, we have 4 stages that can be bypassed:
% 1. Fractional Decimator
% 2. IIR 2.4 MHz
% 3. IIR 5 MHz  
% 4. CIC

% Create all possible bypass combinations (2^4 = 16 combinations)
bypass_combinations = dec2bin(0:15, 4) - '0'; % Convert to binary matrix
num_combinations = size(bypass_combinations, 1);

if (fi_vs_float_var == 0)
    fprintf('Generating %d bypass Fixed Point scenarios...\n\n', num_combinations);

    % Process each bypass combination
    for combo_idx = 1:num_combinations
        % Extract bypass flags for this combination
        bypass_frac_dec = bypass_combinations(combo_idx, 1);
        bypass_iir_24   = bypass_combinations(combo_idx, 2);
        bypass_iir_5    = bypass_combinations(combo_idx, 3);
        bypass_cic      = bypass_combinations(combo_idx, 4);
    
        % Create directory name for this scenario
        scenario_dir = sprintf('scenario_frac%d_iir24%d_iir5%d_cic%d', ...
                            bypass_frac_dec, bypass_iir_24, bypass_iir_5, bypass_cic);
    
        % Create directory if it doesn't exist
        if ~exist(scenario_dir, 'dir')
            mkdir(scenario_dir);
        end
    
        fprintf('Processing scenario %d/%d: %s\n', ...
                combo_idx, num_combinations, scenario_dir);
        fprintf('  Bypass flags - frac_dec:%d, iir_24:%d, iir_5:%d, cic:%d\n', ...
                bypass_frac_dec, bypass_iir_24, bypass_iir_5, bypass_cic);
    
        % Processing chain with current bypass options
        current_signal = x_quantized_noisy;

        % Write Stage 0: Input signal (after quantization)
        writeFixedPointBinary(current_signal, fullfile(scenario_dir, 'input.txt'), 16, 15);

        % Stage 1: Fractional Decimator
        if bypass_frac_dec == 0
            fprintf('  Applying Fractional Decimator...\n');
            Hd_Fractional_Decimator = Fractional_Decimator();
            current_signal = step(Hd_Fractional_Decimator, current_signal);

            % Write Stage 1: After fractional decimator
            writeFixedPointBinary(current_signal, fullfile(scenario_dir, 'frac_decimator.txt'), 16, 15);
        else
            fprintf('  Bypassing Fractional Decimator\n');
            copyfile(fullfile(scenario_dir, 'input.txt'), ...
                    fullfile(scenario_dir, 'frac_decimator.txt'));
        end

        % Stage 2: IIR 2.4MHz Notch Filter
        if bypass_iir_24 == 0
            fprintf('  Applying IIR 2.4MHz Notch Filter...\n');
            Hd_IIR_2_4 = IIR_2_4();
            current_signal = filter(Hd_IIR_2_4, current_signal);

            % Write Stage 2: After IIR 2.4MHz filter
            writeFixedPointBinary(current_signal, fullfile(scenario_dir, 'iir_24mhz.txt'), 16, 15);
        else
            fprintf('  Bypassing IIR 2.4MHz Notch Filter\n');
            copyfile(fullfile(scenario_dir, 'frac_decimator.txt'), ...
                    fullfile(scenario_dir, 'iir_24mhz.txt'));
        end

        % Stage 3: IIR 5MHz Notch Filter (both IIR_1 and IIR_2)
        if bypass_iir_5 == 0
            fprintf('  Applying IIR 5MHz Notch Filter...\n');
            Hd_IIR_1 = IIR_1(); 
            Hd_IIR_2 = IIR_2();
            current_signal_PH1 = filter(Hd_IIR_1, current_signal);

            % Write Stage 3.1: After first IIR 5MHz filter
            writeFixedPointBinary(current_signal_PH1, fullfile(scenario_dir, 'iir_5mhz_1.txt'), 16, 15);

            current_signal = filter(Hd_IIR_2, current_signal_PH1);

            % Write Stage 3.2: After second IIR 5MHz filter
            writeFixedPointBinary(current_signal, fullfile(scenario_dir, 'iir_5mhz_2.txt'), 16, 15);
        else
            fprintf('  Bypassing IIR 5MHz Notch Filter\n');
            copyfile(fullfile(scenario_dir, 'iir_24mhz.txt'), ...
                     fullfile(scenario_dir, 'iir_5mhz_1.txt'));
            copyfile(fullfile(scenario_dir, 'iir_24mhz.txt'), ...
                     fullfile(scenario_dir, 'iir_5mhz_2.txt'));
        end

        % Stage 4: CIC Filter
        if bypass_cic == 0
            fprintf('  Applying CIC Filter with decimation factor %d...\n', cic_decf);
            Hd_cic = CIC(cic_decf);
            current_signal = step(Hd_cic, current_signal);

            % Write Stage 4: After CIC filter
            writeFixedPointBinary(current_signal, fullfile(scenario_dir, 'cic.txt'), 16, 15);
        else
            fprintf('  Bypassing CIC Filter\n');
            copyfile(fullfile(scenario_dir, 'iir_5mhz_2.txt'), ...
                    fullfile(scenario_dir, 'cic.txt'));
        end

        % Final output
        output = current_signal;
        writeFixedPointBinary(output, fullfile(scenario_dir, 'output.txt'), 16, 15);
    
        fprintf('  Scenario %s complete!\n\n', scenario_dir);
    end
else
    fprintf('Generating %d bypass Floating Point scenarios...\n\n', num_combinations);
    
    % Process each bypass combination
    for combo_idx = 1:num_combinations
        % Extract bypass flags for this combination
        bypass_frac_dec = bypass_combinations(combo_idx, 1);
        bypass_iir_24   = bypass_combinations(combo_idx, 2);
        bypass_iir_5    = bypass_combinations(combo_idx, 3);
        bypass_cic      = bypass_combinations(combo_idx, 4);
    
        % Create directory name for this scenario
        scenario_dir = sprintf('scenario_frac%d_iir24%d_iir5%d_cic%d', ...
                            bypass_frac_dec, bypass_iir_24, bypass_iir_5, bypass_cic);
    
        % Create directory if it doesn't exist
        if ~exist(scenario_dir, 'dir')
            mkdir(scenario_dir);
        end
    
        fprintf('Processing scenario %d/%d: %s\n', ...
                combo_idx, num_combinations, scenario_dir);
        fprintf('  Bypass flags - frac_dec:%d, iir_24:%d, iir_5:%d, cic:%d\n', ...
                bypass_frac_dec, bypass_iir_24, bypass_iir_5, bypass_cic);
    
        % Processing chain with current bypass options
        current_signal = x_quantized_noisy;

        % Write Stage 0: Input signal (after quantization)
        writeFixedPointBinary(current_signal, fullfile(scenario_dir, 'input.txt'), 16, 15);

        % Stage 1: Fractional Decimator
        if bypass_frac_dec == 0
            fprintf('  Applying Fractional Decimator...\n');
            Hd_Fractional_Decimator_float = Fractional_Decimator_float();
            current_signal = step(Hd_Fractional_Decimator_float, current_signal);

            % Write Stage 1: After fractional decimator
            writeFloatingDouble(current_signal, fullfile(scenario_dir, 'frac_decimator.txt'));
        else
            fprintf('  Bypassing Fractional Decimator\n');
            copyfile(fullfile(scenario_dir, 'input.txt'), ...
                    fullfile(scenario_dir, 'frac_decimator.txt'));
        end

        % Stage 2: IIR 2.4MHz Notch Filter
        if bypass_iir_24 == 0
            fprintf('  Applying IIR 2.4MHz Notch Filter...\n');
            Hd_IIR_2_4_float = IIR_2_4_float();
            current_signal = filter(Hd_IIR_2_4_float, current_signal);

            % Write Stage 2: After IIR 2.4MHz filter
            writeFloatingDouble(current_signal, fullfile(scenario_dir, 'iir_24mhz.txt'));
        else
            fprintf('  Bypassing IIR 2.4MHz Notch Filter\n');
            copyfile(fullfile(scenario_dir, 'frac_decimator.txt'), ...
                    fullfile(scenario_dir, 'iir_24mhz.txt'));
        end

        % Stage 3: IIR 5MHz Notch Filter (both IIR_1 and IIR_2)
        if bypass_iir_5 == 0
            fprintf('  Applying IIR 5MHz Notch Filter...\n');
            Hd_IIR_1_float = IIR_1_float(); 
            Hd_IIR_2_float = IIR_2_float();
            current_signal_PH1 = filter(Hd_IIR_1_float, current_signal);

            % Write Stage 3.1: After first IIR 5MHz filter
            writeFloatingDouble(current_signal_PH1, fullfile(scenario_dir, 'iir_5mhz_1.txt'));

            current_signal = filter(Hd_IIR_2_float, current_signal_PH1);

            % Write Stage 3.2: After second IIR 5MHz filter
            writeFloatingDouble(current_signal, fullfile(scenario_dir, 'iir_5mhz_2.txt'));
        else
            fprintf('  Bypassing IIR 5MHz Notch Filter\n');
            copyfile(fullfile(scenario_dir, 'iir_24mhz.txt'), ...
                     fullfile(scenario_dir, 'iir_5mhz_1.txt'));
            copyfile(fullfile(scenario_dir, 'iir_24mhz.txt'), ...
                     fullfile(scenario_dir, 'iir_5mhz_2.txt'));
        end

        % Stage 4: CIC Filter
        if bypass_cic == 0
            fprintf('  Applying CIC Filter with decimation factor %d...\n', cic_decf);
            Hd_cic_float = CIC_float(cic_decf);
            current_signal = step(Hd_cic_float, current_signal);

            % Write Stage 4: After CIC filter
            writeFloatingDouble(current_signal, fullfile(scenario_dir, 'cic.txt'));
        else
            fprintf('  Bypassing CIC Filter\n');
            copyfile(fullfile(scenario_dir, 'iir_5mhz_2.txt'), ...
                    fullfile(scenario_dir, 'cic.txt'));
        end

        % Final output
        output = current_signal;
        writeFloatingDouble(output, fullfile(scenario_dir, 'output.txt'));
    
        fprintf('  Scenario %s complete!\n\n', scenario_dir);
    end
end
fprintf('All %d scenarios processed successfully!\n', num_combinations);
fprintf('Outputs saved in separate directories:\n');

% List all scenario directories
for combo_idx = 1:num_combinations
    bypass_frac_dec = bypass_combinations(combo_idx, 1);
    bypass_iir_24   = bypass_combinations(combo_idx, 2);
    bypass_iir_5    = bypass_combinations(combo_idx, 3);
    bypass_cic      = bypass_combinations(combo_idx, 4);
    
    scenario_dir = sprintf('scenario_frac%d_iir24%d_iir5%d_cic%d', ...
                          bypass_frac_dec, bypass_iir_24, bypass_iir_5, bypass_cic);
    
    fprintf('  %s/\n', scenario_dir);
    fprintf('    input.txt\n');
    fprintf('    frac_decimator.txt\n');
    fprintf('    iir_24mhz.txt\n');
    fprintf('    iir_5mhz_1.txt\n');
    fprintf('    iir_5mhz_2.txt\n');
    fprintf('    cic.txt\n');
    fprintf('    output.txt\n\n');
end