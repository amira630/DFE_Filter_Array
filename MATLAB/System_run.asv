clear
clc

% Read binary configuration from file
config = readBinaryConfig('cfg.txt');

% Extract values from binary configuration
% Signal configuration flags (bits 1-3)
f = config(1);
a = config(2);  
s = config(3);

% Bypass flags (bits 4-7)
bypass_frac_dec = config(4);
bypass_iir_24   = config(5);
bypass_iir_5    = config(6);
bypass_cic      = config(7);

% CIC Configuration (bits 8-12 as 5-bit value)
cic_decf_binary = config(8:12);
cic_decf = binaryVectorToDecimal(cic_decf_binary);

% Default parameters
default_freq = 1e5;      % 100 kHz
default_amp = 0.25;      % Default amplitude
default_shape = 'sine';  % Default shape

% Parameter ranges for randomization
freq_range = [50e3, 200e3];   % Frequency range: 50 kHz to 200 kHz
amp_range = [0.1, 0.5];       % Amplitude range: 0.1 to 0.5
shape_options = {'sine', 'square', 'triangular'};

% Determine final parameters based on flags
if f == 1
    f_sig = freq_range(1) + (freq_range(2) - freq_range(1)) * rand();
else
    f_sig = default_freq;
end

if a == 1
    amplitude = amp_range(1) + (amp_range(2) - amp_range(1)) * rand();
else
    amplitude = default_amp;
end

if s == 1
    shape_idx = randi([1, length(shape_options)]);
    signal_shape = shape_options{shape_idx};
else
    signal_shape = default_shape;
end

% Display configuration
fprintf('Binary Configuration:\n');
fprintf('Raw bits: ');
fprintf('%d', config);
fprintf('\n\n');

fprintf('Parsed Configuration:\n');
fprintf('Signal flags - f:%d, a:%d, s:%d\n', f, a, s);
fprintf('Bypass flags - frac_dec:%d, iir_24:%d, iir_5:%d, cic:%d\n', ...
        bypass_frac_dec, bypass_iir_24, bypass_iir_5, bypass_cic);
fprintf('CIC decf (binary %s) = %d\n', ...
        num2str(cic_decf_binary), cic_decf);
fprintf('Generated signal - Freq: %.2f kHz, Amp: %.3f, Shape: %s\n\n', ...
        f_sig/1000, amplitude, signal_shape);

Fs = 9e6;        
N  = 48000;      

t = (0 : N - 1)' / Fs;                    

% Generate clean signal based on selected shape
switch signal_shape
    case 'sine'
        x_real_clean = amplitude * sin(2 * pi * f_sig * t);
    case 'square'
        x_real_clean = amplitude * square(2 * pi * f_sig * t);
    case 'triangular'
        x_real_clean = amplitude * sawtooth(2 * pi * f_sig * t, 0.5);
end

% Add interference
f_intf_2_4 = 2.4e6;    
f_intf_5 = 5e6;      
A_intf_2_4 = 0.2;
A_intf_5 = 0.2;

intf1 = (A_intf_2_4 * sin(2 * pi * f_intf_2_4 * t));
intf2 = (A_intf_5 * sin(2 * pi * f_intf_5 * t));
interference = intf1 + intf2;
x_real_noisy = x_real_clean + interference;

x_quantized_noisy = fi(x_real_noisy, 1, 16, 15);

% Processing chain with bypass options
current_signal = x_quantized_noisy;

% Write Stage 0: Input signal (after quantization)
writeFixedPointBinary(current_signal, 'input.txt', 16, 15);

% Stage 1: Fractional Decimator
if bypass_frac_dec == 0
    fprintf('Applying Fractional Decimator...\n');
    Hd_Fractional_Decimator = Fractional_Decimator();
    current_signal = step(Hd_Fractional_Decimator, current_signal);

    % Write Stage 1: After fractional decimator
    writeFixedPointBinary(current_signal, 'frac_decimator.txt', 16, 15);
else
    fprintf('Bypassing Fractional Decimator\n');
    copyfile('input.txt', 'frac_decimator.txt');
end

% Stage 2: IIR 2.4MHz Notch Filter
if bypass_iir_24 == 0
    fprintf('Applying IIR 2.4MHz Notch Filter...\n');
    Hd_IIR_2_4 = IIR_2_4();
    current_signal = filter(Hd_IIR_2_4, current_signal);

    % Write Stage 2: After IIR 2.4MHz filter
    writeFixedPointBinary(current_signal, 'iir_24mhz.txt', 16, 15);
else
    fprintf('Bypassing IIR 2.4MHz Notch Filter\n');
    copyfile('frac_decimator.txt', 'iir_24mhz.txt');
end

% Stage 3: IIR 5MHz Notch Filter (both IIR_1 and IIR_2)
if bypass_iir_5 == 0
    fprintf('Applying IIR 5MHz Notch Filter...\n');
    Hd_IIR_1 = IIR_1(); 
    Hd_IIR_2 = IIR_2();
    current_signal_PH1 = filter(Hd_IIR_1, current_signal);

    % Write Stage 3.1: After first IIR 5MHz filter
    writeFixedPointBinary(current_signal_PH1, 'iir_5mhz_1.txt', 16, 15);

    current_signal = filter(Hd_IIR_2, current_signal_PH1);

    % Write Stage 3.2: After second IIR 5MHz filter
    writeFixedPointBinary(current_signal, 'iir_5mhz_2.txt', 16, 15);
else
    fprintf('Bypassing IIR 5MHz Notch Filter\n');
    copyfile('iir_24mhz.txt', 'iir_5mhz_1.txt');
    copyfile('iir_24mhz.txt', 'iir_5mhz_2.txt');
end

% Stage 4: CIC Filter
if bypass_cic == 0
    fprintf('Applying CIC Filter with decimation factor %d...\n', cic_decf);
    Hd_cic = CIC(cic_decf);
    current_signal = step(Hd_cic, current_signal);

    % Write Stage 4: After CIC filter
    writeFixedPointBinary(current_signal, 'cic.txt', 16, 15);
else
    fprintf('Bypassing CIC Filter\n');
    copyfile('iir_5mhz_2.txt', 'cic.txt');
end

% Final output
output = current_signal;

writeFixedPointBinary(output, 'stage7_final_output.txt', 16, 15);
    

fprintf('Processing complete!\n');